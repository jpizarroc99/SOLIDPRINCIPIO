S - Single Responsibility Principle (SRP)
Principio de Responsabilidad √önica

‚úÖ ¬øQu√© significa?
Una clase debe tener una √∫nica raz√≥n para cambiar, es decir, una sola responsabilidad o funci√≥n bien definida.

Esto quiere decir que cada clase debe encargarse de una sola parte del comportamiento del sistema, y nada m√°s. Si una clase hace muchas cosas distintas, es m√°s dif√≠cil de mantener, probar o modificar sin romper otras funcionalidades.

üß† Ejemplo simple:
Sup√≥n que tienes una clase Reporte que:

Genera un reporte de ventas.

Imprime el reporte.

Lo guarda en disco.

java
Copiar
Editar
public class Reporte {
    public void generar() {
        // L√≥gica de generaci√≥n
    }

    public void imprimir() {
        // L√≥gica de impresi√≥n
    }

    public void guardar() {
        // L√≥gica de guardado
    }
}
Esta clase viola SRP porque tiene tres responsabilidades: generar, imprimir y guardar.

‚úÖ Aplicando SRP correctamente:
Separas esas responsabilidades en diferentes clases:

java
Copiar
Editar
public class GeneradorReporte {
    public void generar() {
        // Solo genera el contenido del reporte
    }
}

public class ImpresoraReporte {
    public void imprimir(String reporte) {
        // Solo se encarga de imprimir
    }
}

public class GuardadorReporte {
    public void guardar(String reporte) {
        // Solo se encarga de guardar
    }
}
Ahora, cada clase tiene una sola responsabilidad, y puede cambiar independientemente si cambia la l√≥gica de generaci√≥n, impresi√≥n o guardado.

üß© Beneficios del SRP:
C√≥digo m√°s modular y legible.

Facilita las pruebas unitarias.

Favorece la reutilizaci√≥n de componentes.

Reduce el riesgo de errores colaterales al hacer cambios.

O - Open/Closed Principle (OCP)
(Principio de Abierto/Cerrado)

üìò Definici√≥n:
El Open/Closed Principle fue formulado por Bertrand Meyer y forma parte de los principios SOLID, popularizados por Robert C. Martin (Uncle Bob). Este principio establece lo siguiente:

"Las entidades de software (clases, m√≥dulos, funciones, etc.) deben estar abiertas para la extensi√≥n, pero cerradas para la modificaci√≥n."

üí° ¬øQu√© significa esto?
"Abiertas para la extensi√≥n":

Significa que una clase debe poder a√±adir nuevas funcionalidades o comportamientos sin necesidad de alterar su c√≥digo fuente original.

Esto se logra mediante herencia, composici√≥n o interfaces, permitiendo que el software evolucione sin romper lo que ya funciona.

"Cerradas para la modificaci√≥n":

Significa que no debes tener que modificar el c√≥digo existente de una clase para cambiar su comportamiento. Esto evita introducir errores en c√≥digo que ya est√° probado y en producci√≥n.

üîß Ejemplo cl√°sico:
Supongamos que tienes una clase para calcular el √°rea de figuras geom√©tricas:

python
Copiar
Editar
class AreaCalculator:
    def calculate_area(self, shape):
        if shape["type"] == "rectangle":
            return shape["width"] * shape["height"]
        elif shape["type"] == "circle":
            return 3.14 * shape["radius"] ** 2
Este enfoque viola el principio OCP porque si quieres a√±adir otro tipo de figura (por ejemplo, tri√°ngulo), debes modificar el m√©todo calculate_area, lo cual no est√° cerrado a modificaciones.

‚úÖ Aplicaci√≥n correcta del OCP:
python
Copiar
Editar
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class AreaCalculator:
    def calculate_area(self, shape: Shape):
        return shape.area()
Ahora puedes agregar m√°s figuras (como Triangle, Ellipse, etc.) sin modificar el c√≥digo del AreaCalculator. Solo tienes que crear una nueva clase que implemente el m√©todo area().

üéØ Beneficios del OCP:
‚úÖ Facilita el mantenimiento del c√≥digo.

‚úÖ Permite una escalabilidad m√°s segura.

‚úÖ Reduce el riesgo de introducir errores al modificar el c√≥digo existente.

‚úÖ Fomenta la reutilizaci√≥n de c√≥digo mediante abstracciones.

üö´ Riesgos si no se aplica:
Cambios peque√±os pueden afectar muchas partes del sistema.

Mayor posibilidad de errores al alterar c√≥digo probado.

Dificultad para trabajar en equipo si m√∫ltiples personas deben modificar la misma clase.

C√≥digo r√≠gido y poco adaptable al cambio.

üß† Conclusi√≥n:
El principio de Abierto/Cerrado nos ense√±a a dise√±ar sistemas que resistan el paso del tiempo, permitiendo que evolucionen sin que necesitemos tocar el n√∫cleo de lo que ya funciona. En pocas palabras:

"Agrega comportamiento nuevo sin romper lo viejo."

Es uno de los pilares de la programaci√≥n robusta y escalable en proyectos medianos a grandes.